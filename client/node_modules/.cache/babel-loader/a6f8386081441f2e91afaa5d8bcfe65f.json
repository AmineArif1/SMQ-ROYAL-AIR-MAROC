{"ast":null,"code":"/* eslint-disable no-fallthrough */\n\n/* eslint-disable no-bitwise */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst {\n  Transform\n} = require('stream');\n\nconst errors = require('../FormidableError.js');\n\nconst {\n  FormidableError\n} = errors;\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++\n};\nlet f = 1;\nconst FBOUNDARY = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nexports.STATES = {};\nObject.keys(STATE).forEach(stateName => {\n  exports.STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends Transform {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      readableObjectMode: true\n    });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n    this.globalOptions = { ...options\n    };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _flush(done) {\n    if (this.state === STATE.HEADER_FIELD_START && this.index === 0 || this.state === STATE.PART_DATA && this.index === this.boundary.length) {\n      this._handleCallback('partEnd');\n\n      this._handleCallback('end');\n\n      done();\n    } else if (this.state !== STATE.END) {\n      done(new FormidableError(`MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`, errors.malformedMultipart, 400));\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  } // eslint-disable-next-line max-params\n\n\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n\n    this.push({\n      name,\n      buffer: buf,\n      start,\n      end\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let {\n      index,\n      state,\n      flags\n    } = this;\n    const {\n      lookbehind,\n      boundary,\n      boundaryChars\n    } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = name => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          return i;\n\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return i;\n            }\n\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n\n              this._handleCallback('partBegin');\n\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              return i;\n            }\n\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n\n          break;\n\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return i;\n            }\n\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n\n          if (cl < A || cl > Z) {\n            return i;\n          }\n\n          break;\n\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n\n            this._handleCallback('headerEnd');\n\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n\n          break;\n\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          state = STATE.HEADER_FIELD_START;\n          break;\n\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          this._handleCallback('headersEnd');\n\n          state = STATE.PART_DATA_START;\n          break;\n\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n\n                this._handleCallback('partEnd');\n\n                this._handleCallback('partBegin');\n\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n\n                this._handleCallback('end');\n\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n\n            prevIndex = 0;\n            setMark('partData'); // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n\n            i--;\n          }\n\n          break;\n\n        case STATE.END:\n          break;\n\n        default:\n          return i;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n\n} // eslint-disable-next-line consistent-return\n\n\nMultipartParser.stateToString = stateNumber => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nmodule.exports = Object.assign(MultipartParser, {\n  STATES: exports.STATES\n});","map":{"version":3,"names":["Transform","require","errors","FormidableError","s","STATE","PARSER_UNINITIALIZED","START","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","PART_END","END","f","FBOUNDARY","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","exports","STATES","Object","keys","forEach","stateName","MultipartParser","constructor","options","readableObjectMode","boundary","boundaryChars","lookbehind","bufferLength","state","globalOptions","index","flags","_flush","done","length","_handleCallback","explain","malformedMultipart","initWithBoundary","str","Buffer","from","alloc","i","name","buf","start","end","undefined","push","buffer","_transform","_","prevIndex","boundaryLength","boundaryEnd","cl","setMark","idx","clearMarkSymbol","dataCallback","shouldClear","markSymbol","stateToString","stateNumber","number","module","assign"],"sources":["C:/Users/killua/local/pc/Bureau/SMQ-ROYAL-AIR-MAROC/client/node_modules/formidable/src/parsers/Multipart.js"],"sourcesContent":["/* eslint-disable no-fallthrough */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst { Transform } = require('stream');\nconst errors = require('../FormidableError.js');\n\nconst { FormidableError } = errors;\n\nlet s = 0;\nconst STATE = {\n  PARSER_UNINITIALIZED: s++,\n  START: s++,\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  PART_END: s++,\n  END: s++,\n};\n\nlet f = 1;\nconst FBOUNDARY = { PART_BOUNDARY: f, LAST_BOUNDARY: (f *= 2) };\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nfunction lower(c) {\n  return c | 0x20;\n}\n\nexports.STATES = {};\n\nObject.keys(STATE).forEach((stateName) => {\n  exports.STATES[stateName] = STATE[stateName];\n});\n\nclass MultipartParser extends Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true });\n    this.boundary = null;\n    this.boundaryChars = null;\n    this.lookbehind = null;\n    this.bufferLength = 0;\n    this.state = STATE.PARSER_UNINITIALIZED;\n\n    this.globalOptions = { ...options };\n    this.index = null;\n    this.flags = 0;\n  }\n\n  _flush(done) {\n    if (\n      (this.state === STATE.HEADER_FIELD_START && this.index === 0) ||\n      (this.state === STATE.PART_DATA && this.index === this.boundary.length)\n    ) {\n      this._handleCallback('partEnd');\n      this._handleCallback('end');\n      done();\n    } else if (this.state !== STATE.END) {\n      done(\n        new FormidableError(\n          `MultipartParser.end(): stream ended unexpectedly: ${this.explain()}`,\n          errors.malformedMultipart,\n          400,\n        ),\n      );\n    }\n  }\n\n  initWithBoundary(str) {\n    this.boundary = Buffer.from(`\\r\\n--${str}`);\n    this.lookbehind = Buffer.alloc(this.boundary.length + 8);\n    this.state = STATE.START;\n    this.boundaryChars = {};\n\n    for (let i = 0; i < this.boundary.length; i++) {\n      this.boundaryChars[this.boundary[i]] = true;\n    }\n  }\n\n  // eslint-disable-next-line max-params\n  _handleCallback(name, buf, start, end) {\n    if (start !== undefined && start === end) {\n      return;\n    }\n    this.push({ name, buffer: buf, start, end });\n  }\n\n  // eslint-disable-next-line max-statements\n  _transform(buffer, _, done) {\n    let i = 0;\n    let prevIndex = this.index;\n    let { index, state, flags } = this;\n    const { lookbehind, boundary, boundaryChars } = this;\n    const boundaryLength = boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    this.bufferLength = buffer.length;\n    let c = null;\n    let cl = null;\n\n    const setMark = (name, idx) => {\n      this[`${name}Mark`] = typeof idx === 'number' ? idx : i;\n    };\n\n    const clearMarkSymbol = (name) => {\n      delete this[`${name}Mark`];\n    };\n\n    const dataCallback = (name, shouldClear) => {\n      const markSymbol = `${name}Mark`;\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (!shouldClear) {\n        this._handleCallback(name, buffer, this[markSymbol], buffer.length);\n        setMark(name, 0);\n      } else {\n        this._handleCallback(name, buffer, this[markSymbol], i);\n        clearMarkSymbol(name);\n      }\n    };\n\n    for (i = 0; i < this.bufferLength; i++) {\n      c = buffer[i];\n      switch (state) {\n        case STATE.PARSER_UNINITIALIZED:\n          return i;\n        case STATE.START:\n          index = 0;\n          state = STATE.START_BOUNDARY;\n        case STATE.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return i;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & FBOUNDARY.LAST_BOUNDARY && c === HYPHEN) {\n              this._handleCallback('end');\n              state = STATE.END;\n              flags = 0;\n            } else if (!(flags & FBOUNDARY.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              this._handleCallback('partBegin');\n              state = STATE.HEADER_FIELD_START;\n            } else {\n              return i;\n            }\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case STATE.HEADER_FIELD_START:\n          state = STATE.HEADER_FIELD;\n          setMark('headerField');\n          index = 0;\n        case STATE.HEADER_FIELD:\n          if (c === CR) {\n            clearMarkSymbol('headerField');\n            state = STATE.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return i;\n            }\n            dataCallback('headerField', true);\n            state = STATE.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            return i;\n          }\n          break;\n        case STATE.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          setMark('headerValue');\n          state = STATE.HEADER_VALUE;\n        case STATE.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('headerValue', true);\n            this._handleCallback('headerEnd');\n            state = STATE.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case STATE.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n          state = STATE.HEADER_FIELD_START;\n          break;\n        case STATE.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return i;\n          }\n\n          this._handleCallback('headersEnd');\n          state = STATE.PART_DATA_START;\n          break;\n        case STATE.PART_DATA_START:\n          state = STATE.PART_DATA;\n          setMark('partData');\n        case STATE.PART_DATA:\n          prevIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < this.bufferLength && !(buffer[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = buffer[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('partData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= FBOUNDARY.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= FBOUNDARY.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & FBOUNDARY.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~FBOUNDARY.PART_BOUNDARY;\n                this._handleCallback('partEnd');\n                this._handleCallback('partBegin');\n                state = STATE.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & FBOUNDARY.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                this._handleCallback('partEnd');\n                this._handleCallback('end');\n                state = STATE.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (prevIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            this._handleCallback('partData', lookbehind, 0, prevIndex);\n            prevIndex = 0;\n            setMark('partData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n\n          break;\n        case STATE.END:\n          break;\n        default:\n          return i;\n      }\n    }\n\n    dataCallback('headerField');\n    dataCallback('headerValue');\n    dataCallback('partData');\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n\n    done();\n    return this.bufferLength;\n  }\n\n  explain() {\n    return `state = ${MultipartParser.stateToString(this.state)}`;\n  }\n}\n\n// eslint-disable-next-line consistent-return\nMultipartParser.stateToString = (stateNumber) => {\n  // eslint-disable-next-line no-restricted-syntax, guard-for-in\n  for (const stateName in STATE) {\n    const number = STATE[stateName];\n    if (number === stateNumber) return stateName;\n  }\n};\n\nmodule.exports = Object.assign(MultipartParser, { STATES: exports.STATES });\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}