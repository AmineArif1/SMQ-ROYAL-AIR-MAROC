{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst os = require('os');\n\nconst path = require('path');\n\nconst hexoid = require('hexoid');\n\nconst once = require('once');\n\nconst dezalgo = require('dezalgo');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  StringDecoder\n} = require('string_decoder');\n\nconst qs = require('qs');\n\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFileSize: 200 * 1024 * 1024,\n  minFileSize: 1,\n  allowEmptyFiles: true,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  multiples: false,\n  enabledPlugins: ['octetstream', 'querystring', 'multipart', 'json'],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter: function () {\n    return true;\n  }\n};\n\nconst PersistentFile = require('./PersistentFile');\n\nconst VolatileFile = require('./VolatileFile');\n\nconst DummyParser = require('./parsers/Dummy');\n\nconst MultipartParser = require('./parsers/Multipart');\n\nconst errors = require('./FormidableError.js');\n\nconst {\n  FormidableError\n} = errors;\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nclass IncomingForm extends EventEmitter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.options = { ...DEFAULT_OPTIONS,\n      ...options\n    };\n    const dir = path.resolve(this.options.uploadDir || this.options.uploaddir || os.tmpdir());\n    this.uploaddir = dir;\n    this.uploadDir = dir; // initialize with null\n\n    ['error', 'headers', 'type', 'bytesExpected', 'bytesReceived', '_parser'].forEach(key => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._fileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n    this.options.enabledPlugins = [].concat(this.options.enabledPlugins).filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError('expect at least 1 enabled builtin plugin, see options.enabledPlugins', errors.missingPlugin);\n    }\n\n    this.options.enabledPlugins.forEach(pluginName => {\n      const plgName = pluginName.toLowerCase(); // eslint-disable-next-line import/no-dynamic-require, global-require\n\n      this.use(require(path.join(__dirname, 'plugins', `${plgName}.js`)));\n    });\n\n    this._setUpMaxFields();\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError('.use: expect `plugin` to be a function', errors.pluginFunction);\n    }\n\n    this._plugins.push(plugin.bind(this));\n\n    return this;\n  }\n\n  parse(req, cb) {\n    this.pause = () => {\n      try {\n        req.pause();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n\n        return false;\n      }\n\n      return true;\n    };\n\n    this.resume = () => {\n      try {\n        req.resume();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n\n        return false;\n      }\n\n      return true;\n    }; // Setup callback first, so we don't miss anything from data events emitted immediately.\n\n\n    if (cb) {\n      const callback = once(dezalgo(cb));\n      const fields = {};\n      let mockFields = '';\n      const files = {};\n      this.on('field', (name, value) => {\n        if (this.options.multiples && (this.type === 'multipart' || this.type === 'urlencoded')) {\n          const mObj = {\n            [name]: value\n          };\n          mockFields = mockFields ? `${mockFields}&${qs.stringify(mObj)}` : `${qs.stringify(mObj)}`;\n        } else {\n          fields[name] = value;\n        }\n      });\n      this.on('file', (name, file) => {\n        // TODO: too much nesting\n        if (this.options.multiples) {\n          if (hasOwnProp(files, name)) {\n            if (!Array.isArray(files[name])) {\n              files[name] = [files[name]];\n            }\n\n            files[name].push(file);\n          } else {\n            files[name] = file;\n          }\n        } else {\n          files[name] = file;\n        }\n      });\n      this.on('error', err => {\n        callback(err, fields, files);\n      });\n      this.on('end', () => {\n        if (this.options.multiples) {\n          Object.assign(fields, qs.parse(mockFields));\n        }\n\n        callback(null, fields, files);\n      });\n    } // Parse headers and setup the parser, ready to start listening for data.\n\n\n    this.writeHeaders(req.headers); // Start listening for data.\n\n    req.on('error', err => {\n      this._error(err);\n    }).on('aborted', () => {\n      this.emit('aborted');\n\n      this._error(new FormidableError('Request aborted', errors.aborted));\n    }).on('data', buffer => {\n      try {\n        this.write(buffer);\n      } catch (err) {\n        this._error(err);\n      }\n    }).on('end', () => {\n      if (this.error) {\n        return;\n      }\n\n      if (this._parser) {\n        this._parser.end();\n      }\n\n      this._maybeEnd();\n    });\n    return this;\n  }\n\n  writeHeaders(headers) {\n    this.headers = headers;\n\n    this._parseContentLength();\n\n    this._parseContentType();\n\n    if (!this._parser) {\n      this._error(new FormidableError('no parser found', errors.noParser, 415));\n\n      return;\n    }\n\n    this._parser.once('error', error => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n\n    if (!this._parser) {\n      this._error(new FormidableError('uninitialized parser', errors.uninitializedParser));\n\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  pause() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  resume() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    this._handlePart(part);\n  }\n\n  _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(new FormidableError(`the part.originalFilename should be string when it exists`, errors.filenameNotString));\n\n      return;\n    } // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n\n\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(part.transferEncoding || this.options.encoding);\n      part.on('data', buffer => {\n        this._fieldsSize += buffer.length;\n\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(new FormidableError(`options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`, errors.maxFieldsSizeExceeded, 413));\n\n          return;\n        }\n\n        value += decoder.write(buffer);\n      });\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    const newFilename = this._getNewName(part);\n\n    const filepath = this._joinDirectoryName(newFilename);\n\n    const file = this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype\n    });\n\n    file.on('error', err => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n    file.open();\n    this.openedFiles.push(file);\n    part.on('data', buffer => {\n      this._fileSize += buffer.length;\n\n      if (this._fileSize < this.options.minFileSize) {\n        this._error(new FormidableError(`options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${this._fileSize} bytes of file data`, errors.smallerThanMinFileSize, 400));\n\n        return;\n      }\n\n      if (this._fileSize > this.options.maxFileSize) {\n        this._error(new FormidableError(`options.maxFileSize (${this.options.maxFileSize} bytes) exceeded, received ${this._fileSize} bytes of file data`, errors.biggerThanMaxFileSize, 413));\n\n        return;\n      }\n\n      if (buffer.length === 0) {\n        return;\n      }\n\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && this._fileSize === 0) {\n        this._error(new FormidableError(`options.allowEmptyFiles is false, file size should be greather than 0`, errors.noEmptyFiles, 400));\n\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n\n        this._maybeEnd();\n      });\n    });\n  } // eslint-disable-next-line max-statements\n\n\n  _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(new FormidableError('bad content-type header, no content-type', errors.missingContentType, 400));\n\n      return;\n    }\n\n    const results = [];\n\n    const _dummyParser = new DummyParser(this, this.options); // eslint-disable-next-line no-plusplus\n\n\n    for (let idx = 0; idx < this._plugins.length; idx++) {\n      const plugin = this._plugins[idx];\n      let pluginReturn = null;\n\n      try {\n        pluginReturn = plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(`plugin on index ${idx} failed with: ${err.message}`, errors.pluginFailed, 500);\n        error.idx = idx;\n        throw error;\n      }\n\n      Object.assign(this, pluginReturn); // todo: use Set/Map and pass plugin name instead of the `idx` index\n\n      this.emit('plugin', idx, pluginReturn);\n      results.push(pluginReturn);\n    }\n\n    this.emit('pluginsResults', results); // NOTE: probably not needed, because we check options.enabledPlugins in the constructor\n    // if (results.length === 0 /* && results.length !== this._plugins.length */) {\n    //   this._error(\n    //     new Error(\n    //       `bad content-type header, unknown content-type: ${this.headers['content-type']}`,\n    //     ),\n    //   );\n    // }\n  }\n\n  _error(err) {\n    let eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'error';\n\n    // if (!err && this.error) {\n    //   this.emit('error', this.error);\n    //   return;\n    // }\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.error = err;\n    this.emit(eventName, err);\n\n    if (Array.isArray(this.openedFiles)) {\n      this.openedFiles.forEach(file => {\n        file.destroy();\n      });\n    }\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n\n  _newFile(_ref) {\n    let {\n      filepath,\n      originalFilename,\n      mimetype,\n      newFilename\n    } = _ref;\n    return this.options.fileWriteStreamHandler ? new VolatileFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      createFileWriteStream: this.options.fileWriteStreamHandler,\n      hashAlgorithm: this.options.hashAlgorithm\n    }) : new PersistentFile({\n      newFilename,\n      filepath,\n      originalFilename,\n      mimetype,\n      hashAlgorithm: this.options.hashAlgorithm\n    });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i);\n    if (!m) return null;\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) => String.fromCharCode(code));\n    return originalFilename;\n  }\n\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    const extname = path.extname(basename).replace(/(\\.[a-z0-9]+).*/i, '$1');\n\n    if (firstDot === lastDot) {\n      return extname;\n    }\n\n    return basename.slice(firstDot, lastDot) + extname;\n  }\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name); // prevent directory traversal attacks\n\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n\n    if (hasRename) {\n      this._getNewName = part => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n\n        if (part.originalFilename) {\n          // can be null\n          ({\n            ext,\n            name\n          } = path.parse(part.originalFilename));\n\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = part => {\n        const name = toHexoId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename = typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n\n        return name;\n      };\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== 0) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n\n        if (fieldsCount > this.options.maxFields) {\n          this._error(new FormidableError(`options.maxFields (${this.options.maxFields}) exceeded`, errors.maxFieldsExceeded, 413));\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    // console.log('ended', this.ended);\n    // console.log('_flushing', this._flushing);\n    // console.log('error', this.error);\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n\n    this.emit('end');\n  }\n\n}\n\nIncomingForm.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nmodule.exports = IncomingForm;","map":{"version":3,"names":["os","require","path","hexoid","once","dezalgo","EventEmitter","StringDecoder","qs","toHexoId","DEFAULT_OPTIONS","maxFields","maxFieldsSize","maxFileSize","minFileSize","allowEmptyFiles","keepExtensions","encoding","hashAlgorithm","uploadDir","tmpdir","multiples","enabledPlugins","fileWriteStreamHandler","defaultInvalidName","filter","PersistentFile","VolatileFile","DummyParser","MultipartParser","errors","FormidableError","hasOwnProp","obj","key","Object","prototype","hasOwnProperty","call","IncomingForm","constructor","options","dir","resolve","uploaddir","forEach","_setUpRename","_flushing","_fieldsSize","_fileSize","_plugins","openedFiles","concat","Boolean","length","missingPlugin","pluginName","plgName","toLowerCase","use","join","__dirname","_setUpMaxFields","plugin","pluginFunction","push","bind","parse","req","cb","pause","err","ended","_error","resume","callback","fields","mockFields","files","on","name","value","type","mObj","stringify","file","Array","isArray","assign","writeHeaders","headers","emit","aborted","buffer","write","error","_parser","end","_maybeEnd","_parseContentLength","_parseContentType","noParser","uninitializedParser","bytesReceived","bytesExpected","onPart","part","_handlePart","originalFilename","filenameNotString","mimetype","decoder","transferEncoding","maxFieldsSizeExceeded","newFilename","_getNewName","filepath","_joinDirectoryName","_newFile","open","smallerThanMinFileSize","biggerThanMaxFileSize","noEmptyFiles","missingContentType","results","_dummyParser","idx","pluginReturn","message","pluginFailed","eventName","destroy","parseInt","undefined","_newParser","createFileWriteStream","_getFileName","headerValue","m","match","substr","lastIndexOf","replace","_","code","String","fromCharCode","_getExtension","str","basename","firstDot","indexOf","lastDot","extname","slice","newPath","startsWith","hasRename","filename","ext","fieldsCount","maxFieldsExceeded","module","exports"],"sources":["C:/Users/killua/local/pc/Bureau/SMQ-ROYAL-AIR-MAROC/client/node_modules/formidable/src/Formidable.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst os = require('os');\nconst path = require('path');\nconst hexoid = require('hexoid');\nconst once = require('once');\nconst dezalgo = require('dezalgo');\nconst { EventEmitter } = require('events');\nconst { StringDecoder } = require('string_decoder');\nconst qs = require('qs');\n\nconst toHexoId = hexoid(25);\nconst DEFAULT_OPTIONS = {\n  maxFields: 1000,\n  maxFieldsSize: 20 * 1024 * 1024,\n  maxFileSize: 200 * 1024 * 1024,\n  minFileSize: 1,\n  allowEmptyFiles: true,\n  keepExtensions: false,\n  encoding: 'utf-8',\n  hashAlgorithm: false,\n  uploadDir: os.tmpdir(),\n  multiples: false,\n  enabledPlugins: ['octetstream', 'querystring', 'multipart', 'json'],\n  fileWriteStreamHandler: null,\n  defaultInvalidName: 'invalid-name',\n  filter: function () {\n    return true;\n  },\n};\n\nconst PersistentFile = require('./PersistentFile');\nconst VolatileFile = require('./VolatileFile');\nconst DummyParser = require('./parsers/Dummy');\nconst MultipartParser = require('./parsers/Multipart');\nconst errors = require('./FormidableError.js');\n\nconst { FormidableError } = errors;\n\nfunction hasOwnProp(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nclass IncomingForm extends EventEmitter {\n  constructor(options = {}) {\n    super();\n\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n\n    const dir = path.resolve(\n      this.options.uploadDir || this.options.uploaddir || os.tmpdir(),\n    );\n\n    this.uploaddir = dir;\n    this.uploadDir = dir;\n\n    // initialize with null\n    [\n      'error',\n      'headers',\n      'type',\n      'bytesExpected',\n      'bytesReceived',\n      '_parser',\n    ].forEach((key) => {\n      this[key] = null;\n    });\n\n    this._setUpRename();\n\n    this._flushing = 0;\n    this._fieldsSize = 0;\n    this._fileSize = 0;\n    this._plugins = [];\n    this.openedFiles = [];\n\n    this.options.enabledPlugins = []\n      .concat(this.options.enabledPlugins)\n      .filter(Boolean);\n\n    if (this.options.enabledPlugins.length === 0) {\n      throw new FormidableError(\n        'expect at least 1 enabled builtin plugin, see options.enabledPlugins',\n        errors.missingPlugin,\n      );\n    }\n\n    this.options.enabledPlugins.forEach((pluginName) => {\n      const plgName = pluginName.toLowerCase();\n      // eslint-disable-next-line import/no-dynamic-require, global-require\n      this.use(require(path.join(__dirname, 'plugins', `${plgName}.js`)));\n    });\n\n    this._setUpMaxFields();\n  }\n\n  use(plugin) {\n    if (typeof plugin !== 'function') {\n      throw new FormidableError(\n        '.use: expect `plugin` to be a function',\n        errors.pluginFunction,\n      );\n    }\n    this._plugins.push(plugin.bind(this));\n    return this;\n  }\n\n  parse(req, cb) {\n    this.pause = () => {\n      try {\n        req.pause();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n        return false;\n      }\n      return true;\n    };\n\n    this.resume = () => {\n      try {\n        req.resume();\n      } catch (err) {\n        // the stream was destroyed\n        if (!this.ended) {\n          // before it was completed, crash & burn\n          this._error(err);\n        }\n        return false;\n      }\n\n      return true;\n    };\n\n    // Setup callback first, so we don't miss anything from data events emitted immediately.\n    if (cb) {\n      const callback = once(dezalgo(cb));\n      const fields = {};\n      let mockFields = '';\n      const files = {};\n\n      this.on('field', (name, value) => {\n        if (\n          this.options.multiples &&\n          (this.type === 'multipart' || this.type === 'urlencoded')\n        ) {\n          const mObj = { [name]: value };\n          mockFields = mockFields\n            ? `${mockFields}&${qs.stringify(mObj)}`\n            : `${qs.stringify(mObj)}`;\n        } else {\n          fields[name] = value;\n        }\n      });\n      this.on('file', (name, file) => {\n        // TODO: too much nesting\n        if (this.options.multiples) {\n          if (hasOwnProp(files, name)) {\n            if (!Array.isArray(files[name])) {\n              files[name] = [files[name]];\n            }\n            files[name].push(file);\n          } else {\n            files[name] = file;\n          }\n        } else {\n          files[name] = file;\n        }\n      });\n      this.on('error', (err) => {\n        callback(err, fields, files);\n      });\n      this.on('end', () => {\n        if (this.options.multiples) {\n          Object.assign(fields, qs.parse(mockFields));\n        }\n        callback(null, fields, files);\n      });\n    }\n\n    // Parse headers and setup the parser, ready to start listening for data.\n    this.writeHeaders(req.headers);\n\n    // Start listening for data.\n    req\n      .on('error', (err) => {\n        this._error(err);\n      })\n      .on('aborted', () => {\n        this.emit('aborted');\n        this._error(new FormidableError('Request aborted', errors.aborted));\n      })\n      .on('data', (buffer) => {\n        try {\n          this.write(buffer);\n        } catch (err) {\n          this._error(err);\n        }\n      })\n      .on('end', () => {\n        if (this.error) {\n          return;\n        }\n        if (this._parser) {\n          this._parser.end();\n        }\n        this._maybeEnd();\n      });\n\n    return this;\n  }\n\n  writeHeaders(headers) {\n    this.headers = headers;\n    this._parseContentLength();\n    this._parseContentType();\n\n    if (!this._parser) {\n      this._error(\n        new FormidableError(\n          'no parser found',\n          errors.noParser,\n          415, // Unsupported Media Type\n        ),\n      );\n      return;\n    }\n\n    this._parser.once('error', (error) => {\n      this._error(error);\n    });\n  }\n\n  write(buffer) {\n    if (this.error) {\n      return null;\n    }\n    if (!this._parser) {\n      this._error(\n        new FormidableError('uninitialized parser', errors.uninitializedParser),\n      );\n      return null;\n    }\n\n    this.bytesReceived += buffer.length;\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n    this._parser.write(buffer);\n\n    return this.bytesReceived;\n  }\n\n  pause() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  resume() {\n    // this does nothing, unless overwritten in IncomingForm.parse\n    return false;\n  }\n\n  onPart(part) {\n    // this method can be overwritten by the user\n    this._handlePart(part);\n  }\n\n  _handlePart(part) {\n    if (part.originalFilename && typeof part.originalFilename !== 'string') {\n      this._error(\n        new FormidableError(\n          `the part.originalFilename should be string when it exists`,\n          errors.filenameNotString,\n        ),\n      );\n      return;\n    }\n\n    // This MUST check exactly for undefined. You can not change it to !part.originalFilename.\n\n    // todo: uncomment when switch tests to Jest\n    // console.log(part);\n\n    // ? NOTE(@tunnckocore): no it can be any falsey value, it most probably depends on what's returned\n    // from somewhere else. Where recently I changed the return statements\n    // and such thing because code style\n    // ? NOTE(@tunnckocore): or even better, if there is no mimetype, then it's for sure a field\n    // ? NOTE(@tunnckocore): originalFilename is an empty string when a field?\n    if (!part.mimetype) {\n      let value = '';\n      const decoder = new StringDecoder(\n        part.transferEncoding || this.options.encoding,\n      );\n\n      part.on('data', (buffer) => {\n        this._fieldsSize += buffer.length;\n        if (this._fieldsSize > this.options.maxFieldsSize) {\n          this._error(\n            new FormidableError(\n              `options.maxFieldsSize (${this.options.maxFieldsSize} bytes) exceeded, received ${this._fieldsSize} bytes of field data`,\n              errors.maxFieldsSizeExceeded,\n              413, // Payload Too Large\n            ),\n          );\n          return;\n        }\n        value += decoder.write(buffer);\n      });\n\n      part.on('end', () => {\n        this.emit('field', part.name, value);\n      });\n      return;\n    }\n\n    if (!this.options.filter(part)) {\n      return;\n    }\n\n    this._flushing += 1;\n\n    const newFilename = this._getNewName(part);\n    const filepath = this._joinDirectoryName(newFilename);\n    const file = this._newFile({\n      newFilename,\n      filepath,\n      originalFilename: part.originalFilename,\n      mimetype: part.mimetype,\n    });\n    file.on('error', (err) => {\n      this._error(err);\n    });\n    this.emit('fileBegin', part.name, file);\n\n    file.open();\n    this.openedFiles.push(file);\n\n    part.on('data', (buffer) => {\n      this._fileSize += buffer.length;\n      if (this._fileSize < this.options.minFileSize) {\n        this._error(\n          new FormidableError(\n            `options.minFileSize (${this.options.minFileSize} bytes) inferior, received ${this._fileSize} bytes of file data`,\n            errors.smallerThanMinFileSize,\n            400,\n          ),\n        );\n        return;\n      }\n      if (this._fileSize > this.options.maxFileSize) {\n        this._error(\n          new FormidableError(\n            `options.maxFileSize (${this.options.maxFileSize} bytes) exceeded, received ${this._fileSize} bytes of file data`,\n            errors.biggerThanMaxFileSize,\n            413,\n          ),\n        );\n        return;\n      }\n      if (buffer.length === 0) {\n        return;\n      }\n      this.pause();\n      file.write(buffer, () => {\n        this.resume();\n      });\n    });\n\n    part.on('end', () => {\n      if (!this.options.allowEmptyFiles && this._fileSize === 0) {\n        this._error(\n          new FormidableError(\n            `options.allowEmptyFiles is false, file size should be greather than 0`,\n            errors.noEmptyFiles,\n            400,\n          ),\n        );\n        return;\n      }\n\n      file.end(() => {\n        this._flushing -= 1;\n        this.emit('file', part.name, file);\n        this._maybeEnd();\n      });\n    });\n  }\n\n  // eslint-disable-next-line max-statements\n  _parseContentType() {\n    if (this.bytesExpected === 0) {\n      this._parser = new DummyParser(this, this.options);\n      return;\n    }\n\n    if (!this.headers['content-type']) {\n      this._error(\n        new FormidableError(\n          'bad content-type header, no content-type',\n          errors.missingContentType,\n          400,\n        ),\n      );\n      return;\n    }\n\n    const results = [];\n    const _dummyParser = new DummyParser(this, this.options);\n\n    // eslint-disable-next-line no-plusplus\n    for (let idx = 0; idx < this._plugins.length; idx++) {\n      const plugin = this._plugins[idx];\n\n      let pluginReturn = null;\n\n      try {\n        pluginReturn = plugin(this, this.options) || this;\n      } catch (err) {\n        // directly throw from the `form.parse` method;\n        // there is no other better way, except a handle through options\n        const error = new FormidableError(\n          `plugin on index ${idx} failed with: ${err.message}`,\n          errors.pluginFailed,\n          500,\n        );\n        error.idx = idx;\n        throw error;\n      }\n\n      Object.assign(this, pluginReturn);\n\n      // todo: use Set/Map and pass plugin name instead of the `idx` index\n      this.emit('plugin', idx, pluginReturn);\n      results.push(pluginReturn);\n    }\n\n    this.emit('pluginsResults', results);\n\n    // NOTE: probably not needed, because we check options.enabledPlugins in the constructor\n    // if (results.length === 0 /* && results.length !== this._plugins.length */) {\n    //   this._error(\n    //     new Error(\n    //       `bad content-type header, unknown content-type: ${this.headers['content-type']}`,\n    //     ),\n    //   );\n    // }\n  }\n\n  _error(err, eventName = 'error') {\n    // if (!err && this.error) {\n    //   this.emit('error', this.error);\n    //   return;\n    // }\n    if (this.error || this.ended) {\n      return;\n    }\n\n    this.error = err;\n    this.emit(eventName, err);\n\n    if (Array.isArray(this.openedFiles)) {\n      this.openedFiles.forEach((file) => {\n        file.destroy();\n      });\n    }\n  }\n\n  _parseContentLength() {\n    this.bytesReceived = 0;\n    if (this.headers['content-length']) {\n      this.bytesExpected = parseInt(this.headers['content-length'], 10);\n    } else if (this.headers['transfer-encoding'] === undefined) {\n      this.bytesExpected = 0;\n    }\n\n    if (this.bytesExpected !== null) {\n      this.emit('progress', this.bytesReceived, this.bytesExpected);\n    }\n  }\n\n  _newParser() {\n    return new MultipartParser(this.options);\n  }\n\n  _newFile({ filepath, originalFilename, mimetype, newFilename }) {\n    return this.options.fileWriteStreamHandler\n      ? new VolatileFile({\n          newFilename,\n          filepath,\n          originalFilename,\n          mimetype,\n          createFileWriteStream: this.options.fileWriteStreamHandler,\n          hashAlgorithm: this.options.hashAlgorithm,\n        })\n      : new PersistentFile({\n          newFilename,\n          filepath,\n          originalFilename,\n          mimetype,\n          hashAlgorithm: this.options.hashAlgorithm,\n        });\n  }\n\n  _getFileName(headerValue) {\n    // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n    const m = headerValue.match(\n      /\\bfilename=(\"(.*?)\"|([^()<>{}[\\]@,;:\"?=\\s/\\t]+))($|;\\s)/i,\n    );\n    if (!m) return null;\n\n    const match = m[2] || m[3] || '';\n    let originalFilename = match.substr(match.lastIndexOf('\\\\') + 1);\n    originalFilename = originalFilename.replace(/%22/g, '\"');\n    originalFilename = originalFilename.replace(/&#([\\d]{4});/g, (_, code) =>\n      String.fromCharCode(code),\n    );\n\n    return originalFilename;\n  }\n\n  _getExtension(str) {\n    if (!str) {\n      return '';\n    }\n\n    const basename = path.basename(str);\n    const firstDot = basename.indexOf('.');\n    const lastDot = basename.lastIndexOf('.');\n    const extname = path.extname(basename).replace(/(\\.[a-z0-9]+).*/i, '$1');\n\n    if (firstDot === lastDot) {\n      return extname;\n    }\n\n    return basename.slice(firstDot, lastDot) + extname;\n  }\n\n\n\n  _joinDirectoryName(name) {\n    const newPath = path.join(this.uploadDir, name);\n\n    // prevent directory traversal attacks\n    if (!newPath.startsWith(this.uploadDir)) {\n      return path.join(this.uploadDir, this.options.defaultInvalidName);\n    }\n\n    return newPath;\n  }\n\n  _setUpRename() {\n    const hasRename = typeof this.options.filename === 'function';\n    if (hasRename) {\n      this._getNewName = (part) => {\n        let ext = '';\n        let name = this.options.defaultInvalidName;\n        if (part.originalFilename) {\n          // can be null\n          ({ ext, name } = path.parse(part.originalFilename));\n          if (this.options.keepExtensions !== true) {\n            ext = '';\n          }\n        }\n        return this.options.filename.call(this, name, ext, part, this);\n      };\n    } else {\n      this._getNewName = (part) => {\n        const name = toHexoId();\n\n        if (part && this.options.keepExtensions) {\n          const originalFilename = typeof part === 'string' ? part : part.originalFilename;\n          return `${name}${this._getExtension(originalFilename)}`;\n        }\n    \n        return name;\n      }\n    }\n  }\n\n  _setUpMaxFields() {\n    if (this.options.maxFields !== 0) {\n      let fieldsCount = 0;\n      this.on('field', () => {\n        fieldsCount += 1;\n        if (fieldsCount > this.options.maxFields) {\n          this._error(\n            new FormidableError(\n              `options.maxFields (${this.options.maxFields}) exceeded`,\n              errors.maxFieldsExceeded,\n              413,\n            ),\n          );\n        }\n      });\n    }\n  }\n\n  _maybeEnd() {\n    // console.log('ended', this.ended);\n    // console.log('_flushing', this._flushing);\n    // console.log('error', this.error);\n    if (!this.ended || this._flushing || this.error) {\n      return;\n    }\n\n    this.emit('end');\n  }\n}\n\nIncomingForm.DEFAULT_OPTIONS = DEFAULT_OPTIONS;\nmodule.exports = IncomingForm;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}