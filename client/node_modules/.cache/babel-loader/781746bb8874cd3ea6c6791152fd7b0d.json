{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n'use strict';\n\nconst {\n  Stream\n} = require('stream');\n\nconst MultipartParser = require('../parsers/Multipart');\n\nconst errors = require('../FormidableError.js');\n\nconst {\n  FormidableError\n} = errors; // the `options` is also available through the `options` / `formidable.options`\n\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable; // NOTE: we (currently) support both multipart/form-data and multipart/related\n\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError('bad content-type header, no multipart boundary', errors.missingMultipartBoundary, 400);\n\n      self._error(err);\n    }\n  }\n}; // Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\n\n\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = 'multipart';\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n    parser.initWithBoundary(boundary); // eslint-disable-next-line max-statements, consistent-return\n\n    parser.on('data', _ref => {\n      let {\n        name,\n        buffer,\n        start,\n        end\n      } = _ref;\n\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue; // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\n        const m = headerValue.match( // eslint-disable-next-line no-useless-escape\n        /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i);\n\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n                }\n              };\n\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n\n          case 'base64':\n            {\n              const dataPropagation = ctx => {\n                if (ctx.name === 'partData') {\n                  part.transferBuffer += ctx.buffer.slice(ctx.start, ctx.end).toString('ascii');\n                  /*\n                    four bytes (chars) in base64 converts to three bytes in binary\n                    encoding. So we should always work with a number of bytes that\n                    can be divided by 4, it will result in a number of buytes that\n                    can be divided vy 3.\n                    */\n\n                  const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                  part.emit('data', Buffer.from(part.transferBuffer.substring(0, offset), 'base64'));\n                  part.transferBuffer = part.transferBuffer.substring(offset);\n                }\n              };\n\n              const dataStopPropagation = ctx => {\n                if (ctx.name === 'partEnd') {\n                  part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                  part.emit('end');\n                  parser.off('data', dataPropagation);\n                  parser.off('data', dataStopPropagation);\n                }\n              };\n\n              parser.on('data', dataPropagation);\n              parser.on('data', dataStopPropagation);\n              break;\n            }\n\n          default:\n            return this._error(new FormidableError('unknown transfer-encoding', errors.unknownTransferEncoding, 501));\n        }\n\n        this.onPart(part);\n      } else if (name === 'end') {\n        this.ended = true;\n\n        this._maybeEnd();\n      }\n    });\n    this._parser = parser;\n  };\n}","map":{"version":3,"names":["Stream","require","MultipartParser","errors","FormidableError","module","exports","plugin","formidable","options","self","multipart","test","headers","m","match","initMultipart","createInitMultipart","call","err","missingMultipartBoundary","_error","boundary","type","parser","headerField","headerValue","part","initWithBoundary","on","name","buffer","start","end","readable","originalFilename","mimetype","transferEncoding","encoding","transferBuffer","toString","toLowerCase","_getFileName","dataPropagation","ctx","emit","slice","dataStopPropagation","off","offset","parseInt","length","Buffer","from","substring","unknownTransferEncoding","onPart","ended","_maybeEnd","_parser"],"sources":["C:/Users/killua/local/pc/Bureau/SMQ-ROYAL-AIR-MAROC/client/node_modules/formidable/src/plugins/multipart.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n'use strict';\n\nconst { Stream } = require('stream');\nconst MultipartParser = require('../parsers/Multipart');\nconst errors = require('../FormidableError.js');\n\nconst { FormidableError } = errors;\n\n// the `options` is also available through the `options` / `formidable.options`\nmodule.exports = function plugin(formidable, options) {\n  // the `this` context is always formidable, as the first argument of a plugin\n  // but this allows us to customize/test each plugin\n\n  /* istanbul ignore next */\n  const self = this || formidable;\n\n  // NOTE: we (currently) support both multipart/form-data and multipart/related\n  const multipart = /multipart/i.test(self.headers['content-type']);\n\n  if (multipart) {\n    const m = self.headers['content-type'].match(\n      /boundary=(?:\"([^\"]+)\"|([^;]+))/i,\n    );\n    if (m) {\n      const initMultipart = createInitMultipart(m[1] || m[2]);\n      initMultipart.call(self, self, options); // lgtm [js/superfluous-trailing-arguments]\n    } else {\n      const err = new FormidableError(\n        'bad content-type header, no multipart boundary',\n        errors.missingMultipartBoundary,\n        400,\n      );\n      self._error(err);\n    }\n  }\n};\n\n// Note that it's a good practice (but it's up to you) to use the `this.options` instead\n// of the passed `options` (second) param, because when you decide\n// to test the plugin you can pass custom `this` context to it (and so `this.options`)\nfunction createInitMultipart(boundary) {\n  return function initMultipart() {\n    this.type = 'multipart';\n\n    const parser = new MultipartParser(this.options);\n    let headerField;\n    let headerValue;\n    let part;\n\n    parser.initWithBoundary(boundary);\n\n    // eslint-disable-next-line max-statements, consistent-return\n    parser.on('data', ({ name, buffer, start, end }) => {\n      if (name === 'partBegin') {\n        part = new Stream();\n        part.readable = true;\n        part.headers = {};\n        part.name = null;\n        part.originalFilename = null;\n        part.mimetype = null;\n\n        part.transferEncoding = this.options.encoding;\n        part.transferBuffer = '';\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headerField') {\n        headerField += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerValue') {\n        headerValue += buffer.toString(this.options.encoding, start, end);\n      } else if (name === 'headerEnd') {\n        headerField = headerField.toLowerCase();\n        part.headers[headerField] = headerValue;\n\n        // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n        const m = headerValue.match(\n          // eslint-disable-next-line no-useless-escape\n          /\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i,\n        );\n        if (headerField === 'content-disposition') {\n          if (m) {\n            part.name = m[2] || m[3] || '';\n          }\n\n          part.originalFilename = this._getFileName(headerValue);\n        } else if (headerField === 'content-type') {\n          part.mimetype = headerValue;\n        } else if (headerField === 'content-transfer-encoding') {\n          part.transferEncoding = headerValue.toLowerCase();\n        }\n\n        headerField = '';\n        headerValue = '';\n      } else if (name === 'headersEnd') {\n        switch (part.transferEncoding) {\n          case 'binary':\n          case '7bit':\n          case '8bit':\n          case 'utf-8': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.emit('data', ctx.buffer.slice(ctx.start, ctx.end));\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          case 'base64': {\n            const dataPropagation = (ctx) => {\n              if (ctx.name === 'partData') {\n                part.transferBuffer += ctx.buffer\n                  .slice(ctx.start, ctx.end)\n                  .toString('ascii');\n\n                /*\n                  four bytes (chars) in base64 converts to three bytes in binary\n                  encoding. So we should always work with a number of bytes that\n                  can be divided by 4, it will result in a number of buytes that\n                  can be divided vy 3.\n                  */\n                const offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n                part.emit(\n                  'data',\n                  Buffer.from(\n                    part.transferBuffer.substring(0, offset),\n                    'base64',\n                  ),\n                );\n                part.transferBuffer = part.transferBuffer.substring(offset);\n              }\n            };\n            const dataStopPropagation = (ctx) => {\n              if (ctx.name === 'partEnd') {\n                part.emit('data', Buffer.from(part.transferBuffer, 'base64'));\n                part.emit('end');\n                parser.off('data', dataPropagation);\n                parser.off('data', dataStopPropagation);\n              }\n            };\n            parser.on('data', dataPropagation);\n            parser.on('data', dataStopPropagation);\n            break;\n          }\n          default:\n            return this._error(\n              new FormidableError(\n                'unknown transfer-encoding',\n                errors.unknownTransferEncoding,\n                501,\n              ),\n            );\n        }\n\n        this.onPart(part);\n      } else if (name === 'end') {\n        this.ended = true;\n        this._maybeEnd();\n      }\n    });\n\n    this._parser = parser;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}